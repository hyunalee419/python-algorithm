# Array, Vector, ArrayList, LinkedList 차이
## Array
메모리에 연속적으로 할당된 자료구조.
초기 변수 선언시에 배열의 초기 길이를 지정해야 하며, 동적으로 해당 배열의 길이를 변경할 수 없다.
인덱스의 중간에 추가하거나 삭제할 수 없다.
```
arr[4] = 1;
arr[4] = 2;
```
위 코드를 실행할 시에 arr의 4번째 인덱스의 값은 2로 덮어씌어진다.

삭제를 할 시에는 (언어에 따라) null이나 undefined 등으로 값이 변경되며 해당 인덱스는 유지된다.

## Vector
배열의 동적 길이 변경의 단점을 해결하고자 나온 것이 Vector.
Vector는 동적으로 길이 변경이 가능하지만 초기 길이에 2배씩 추가된다.
즉, 길이 10의 Vector가 있고 자료가 꽉 차있는 경우, 하나만 추가하고 싶어도 Vector는 2배의 길이로 변경되어 길이 20인 Vector가 된다.
> Java의 초기 버전인 1.0에서는 이러한 문제를 해소하기 위해 주로 Vector를 사용 하고는 했다. 하지만 Vector 역시 인스턴스 생성시에 capacity가 디폴트로 10개로 정해져 리스트의 개수가 capacity 이상이 되면 두배 씩 늘려 나아가는 전략을 택하고 있다.

Vector는 여러 thread에 대해 safe하다. 따라서, multi thread programming을 할 때, 동기화 처리를 해주지 않아도 된다.

## ArrayList
ArrayList는 메모리 상에 연속적으로 할당되지만 인덱스의 중간 값이 추가되거나 삭제할 시에 임시 배열을 생성해 데이터를 복사는 방식으로 되어있어 해당 인덱스도 변경된다.
자료 변경시에 복사하는 방식을 취하기때문에 자료 변경이 많을 경우 성능 저하가 발생할 수 있다.
```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 0]

// 3번째 인덱스의 값 제거
[1, 2, 3, 5, 6, 7, 8, 9, 0]

// 2번째 인덱스에 10 추가
[1, 2, 10, 3, 5, 6, 7, 8, 9, 0]
```

## LinkedList
LinkedList는 메모리 상에 연속적으로 할당되지 않는다. 자료값을 저장하기 위한 공간과 다음 자료으 주소를 저장하기 위한 공간이 필요하기때문에 공간복잡도가 높다.
하지만, 자료의 변경이 많이 발생해도 자료 이동 및 복사 작업이 없이 다음 자료가 저장된 메모리의 주소값만 변경해주면 되어 용이하다.

---


*참조*
- [Java의 LinkedList와 ArrayList에 대한 비교]ttps://www.holaxprogramming.com/2014/02/12/java-list-interface/)
